# Clean Code 之道 

衡量代码质量的唯一标准就是: code review时每分钟的WFT数

### 函数篇

#### 合理的结构

`if`语句应该包含尽可能多的逻辑,

#### 解释变量

此变量的唯一目的是解释其内容是什么

```js
不使用解释变量: 
if(page.hasAttribute("test")){
    .....
}

```

我们可能会这样阅读代码: 当page含有test属性的时候放行,但我们并不到这样做的原因是什么,换句话说"含有test属性"表示什么意思

```js
使用解释变量:
let isTestPage = page.hasAttribute("test")
if(isTestPage){
    ......
}
```

重新阅读使用了解释变量的代码时,我们能获取的信息有:

1. 含有test属性的page是testpage
2. page中只有testpage才进行处理

使用解释变量,代码量虽然增加了,但给代码带来的可读性是无法比拟的

#### 函数单一职责的另一种解释

代码要赋予读者随时退出的能力,我想结合语文能更好的理解这个概念

1. 什么是没有随时退出能力

   ```
   阅读下面这段话:
   太阳在中午的时候,温度就像手伸进滚烫的汤水中一样
   ```

   这句话就没有赋予读者随时退出的能力,我们只有读完了所有细节,才知道: 哦,原来是想说中午很热.

   作为读者,我们不关心是脚伸进热水中,还是手伸进热水中,我们只想最快的知道这句话想表达的意思: 中午很热

2. 什么是具有随时退出的能力

   ```
   阅读下面这段话:
   及其日中如探汤
   ```

   这就赋予了读者随时退出的能力,我们不必知道如何探汤的,就能知道这句话想要表达的意思.当我们想要了解探汤的细节时,可以去查阅

   ,这就赋予了读者前进后退的能力,

那么结合上面的例子类比一下:

"探汤"就是我们封装的函数 ,他封装的内容就是"手伸进滚烫的汤水中".当然在代码世界中"探汤"这个函数内部封装的并不好,因为其中细节还可以进行抽离: "手伸进"这个动作还可以抽离出来 .....

**如何使我们的代码具有随时退出的能力呢?**

1. 抽离

   如一个函数只做一件事,如果你不能有意义的从一个函数中抽取另一个函数,这叫做一个函数只做一件事

2. 合理的命名

   疯狂的抽离函数之后,我们会得到大量的小函数,为了防止各种小函数将我们淹没,一定要赋予其合适的名字来描述这个函数做的什么事情,

   通过命名,将函数构建成一株函数树,根据名字来追踪函数

#### 函数参数的限制

- 数量方面

  一个函数至多三个参数: 从参数的存在性这一点分析就足够头疼了,参数存在情况=2的n次方,当超过三个函数,处理参数的存在性就会耗费我们大量的精力

- 类型方面

  大多数情况下,不应该传递一个Boolean类型的值给我们的函数,因为只要传递了Boolean类型那么函数中至少要用一个if语句,那么为什么在外面将这个if语句的两种情况各封装一个函数





